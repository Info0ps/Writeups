The challenge was about reversing a weak PRNG.
Here is the source code of the challenge.

```{python}
from sage.all import *
from Crypto.Util.number import bytes_to_long

class RNG:

    def __init__(self, seed):
        self.p = next_prime(2**24)
        self.F = GF(self.p)
        self.M = matrix(self.F, 3,3, [bytes_to_long(seed[i:i+3]) for i in range(0, len(seed), 3)])
        self.state = vector(self.F, map(ord, "Mvm"))
        self.gen = self.F(2)

    def get_random_num(self):
        out = self.M * self.state

        for i in range(len(self.state)):
            self.state[i] = self.gen**self.state[i] #On travaille dans un corps fini

        return out * self.state

flag = b"MVM{???????????????????????????}"
seed = flag[4:-1]

rng = RNG(seed)
samples = []

for i in range(9):
    samples.append(rng.get_random_num())

print(f"{samples = }")
# samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781]
```

The principle of the challenge is the following: the flag is used to initialize the seed of a pseudo-random number generator, and the goal is to recover the flag from the first terms of a sequence generated by this PRNG, i.e., to recover the seed from the first terms of the sequences generated with an unknown seed.

The seed which is composed of 27 bytes is used the following way.
It is separed in a sequence of 9 times 3 bytes and each of the $9$ sequences of 3 bytes is converted into an integer which is then mapped into GF(p) for a known prime $p$ (the next prime after 2^24) and used as a coordinate of a 
3x3 matrix $M$.

Then, a known $g=2 \in GF(p)$ and a fixed state vector $s_0 \in GF(p)^3$ are initialized.

Then, the numbers are generated the following way.

From a fixed state $s_i$, the next state $s_{i+1}$ as ```$$s_{i+1} = (g^{s_{i,k}})_{1 \le k \le 3}$$```.
We generate the number $(Ms_i)^T s_{i+1}$ where $T$ denotes the transposed of the vector and then $i$ is incremented by $1$ and $s_{i+2}$ is computed.

The only thing to notice here is that all the state vectors $s_i$ can be precomputed since all the parameters to compute them are known. Also, all the equations are linear in the coordinates of $M$.\
Since we are given $9$ samples, we can obtain $9$ linear equations in the coordinates of $M$, and those equations are independent. Thus, we only have to solve a linear system to conclude. \
Here is part of the solving script (only the part corresponding to matrix inversion in the working field, which was done with sage commandline, has been skipped).

```{python}
# We work in Fp where p is the following prime
p = 16777259

init_vect = [77, 118, 109]
liste_vect = [init_vect]

def next_vect(vect):
    return [pow(2,vect[0],p), pow(2, vect[1], p), pow(2, vect[2], p)]

for i in range(9):
    liste_vect.append(next_vect(liste_vect[-1]))

#print(liste_vect)


linear_sys_vects = []

# Building the matrix corresponding to the linear system to solve

for i in range(len(liste_vect)-1):
    linear_vect = []
    si = liste_vect[i]
    sinext = liste_vect[i+1]
    for k in range(3):
        for l in range(3):
            linear_vect.append((sinext[k]*si[l])%p)
    linear_sys_vects.append(linear_vect)

import numpy as np

matrix = np.array(linear_sys_vects)
samples = [6192533, 82371, 86024, 4218430, 12259879, 16442850, 6736271, 7418630, 15483781]

# I have used sagemath to map the matrix into GF(p), to invert it in this field and to multiply it by the samples
# I have obtained the following results

obtained = [7090542, 3355762, 6252149, 5137236, 3223662, 3497780, 7484255, 7174495, 6698102]

# Now, we simply have to convert them back to bytes in order to recover the flag

from Crypto.Util.number import long_to_bytes

flag = b""
for elem in obtained:
    flag += long_to_bytes(elem)
print(flag)
``` 